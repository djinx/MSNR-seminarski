\section{Efikasan kod}

% Compilation_of_Functional_Languages_by_Program_Tra.pdf

Jedan od najvažnijih problema vezanih za funkcionalne jezike jeste efikasnost izvršavanja. 
	

\subsection{Transformacije $\lambda$-računa}

$\lambda$-račun se koristi zbog svoje jednostavnosti i dovoljno je izražajan da se bilo koji funkcionalan jezik može transformisati u njega. To znači da ako imamo implementaciju $\lambda$ računa, možemo da implementiramo  bilo koji funkcionalan jezik tako što ćemo ga prevesti u $\lambda$-račun. Transformacije se često grupišu u dva skupa:


% Compilation_of_Functional_Languages_by_Program_Tra.pdf + comp-by-trans.pdf
\begin{itemize}
	\item Veliki skup jednostavnih, lokanih transformacija koje su implementirane u okviru dela kompajlera koji nazivamo \textit{pojednostavljivač}. Složenost programa raste jer pojednostavljivač pokušava da izvrši što je moguće više transformacija u jednom prolasku kroz program. Uprkos tome, rezultat nakon tih transformacija često i dalje sadrži delove koji mogu biti dalje transformisani, tako da se ova operacija ponavlja više puta, dokle god ima neđto da se pojednostavi. Transformacije koje spadaju u ovaj skup su $\beta$ odsecanje, umetanje (engl. inlining) i konstanto sklapanje (engl. constant folding).
	
	\item Manji skup složenijih, globalnih transformacija, od kojih se svaka implementira odvojeno. Mnoge se sastoje od faze analize praćene transformacijama koje koriste rezultate analize za otkrivanje pogodnih delova za transformisanje. Mnogi se oslanjaju na to da će pojednostavljivač ‚‚počistiti$"$ k\^ od koji proizvedu, tako da se izbegava ponavljanje transformacija koje su već sadržane u telu pojednostavljivača. Primer transformacije za ovaj skup je  \textit{analiza strogosti} (engl. strictness analasys). 
	
\end{itemize}
  

\subsection{Pattern-matching}

% compilingML.A4.pdf
% The Implementation of Functional Programming Languages
