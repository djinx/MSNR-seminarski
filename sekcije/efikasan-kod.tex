\section{Efikasan kod}

% Compilation_of_Functional_Languages_by_Program_Tra.pdf

Jedan od najvažnijih problema vezanih za funkcionalne jezike jeste efikasnost izvršavanja. 
U nastavku opisujemo tehnike koje se koriste za generisanje efikasnog koda.	


\subsection{Transformacije $\lambda$-računa}

$\lambda$-račun se koristi zbog svoje jednostavnosti i dovoljno je izražajan da se bilo koji funkcionalan jezik može transformisati u njega. To znači da ako imamo implementaciju $\lambda$ računa, možemo da implementiramo  bilo koji funkcionalan jezik tako što ćemo ga prevesti u $\lambda$-račun. Transformacije se često grupišu u dva skupa :


% Compilation_of_Functional_Languages_by_Program_Tra.pdf + comp-by-trans.pdf
\begin{itemize}
	\item Veliki skup jednostavnih, lokanih transformacija koje su implementirane u okviru dela kompajlera koji nazivamo \textit{pojednostavljivač}. Složenost programa raste jer pojednostavljivač pokušava da izvrši što je moguće više transformacija u jednom prolasku kroz program. Uprkos tome, rezultat nakon tih transformacija često i dalje sadrži delove koji mogu biti dalje transformisani, tako da se ova operacija ponavlja više puta, dokle god ima nešto da se pojednostavi. Transformacije koje spadaju u ovaj skup su simplifikacija (engl. \textit{simplification}) \cite{compilation-by-program-transformation}, $\beta$-odsecanje, umetanje (engl. \textit{inlining}) i konstanto sklapanje (engl. \textit{constant folding}).
	
	\item Manji skup složenijih, globalnih transformacija, od kojih se svaka implementira odvojeno. Mnoge se sastoje od faze analize praćene transformacijama koje koriste rezultate analize za otkrivanje pogodnih delova za transformisanje. Mnogi se oslanjaju na to da će pojednostavljivač ‚‚počistiti$"$ k\^ od koji proizvedu, tako da se izbegava ponavljanje transformacija koje su već sadržane u telu pojednostavljivača. Primer transformacije za ovaj skup je  \textit{analiza strogosti} (engl. \textit{strictness analasys}) \cite{haskell-by-program-transformation}. 
	
\end{itemize}
  

\subsection{Umetanje}
% inline.pdf str. 2
Umetanje funkcijskih poziva je dobar metod za unapređivanje performansi programa koji se sastoji iz malih funkcija, kao što je čest slučaj sa funkcionalnim jezicima. U suštini, umetanje je veoma jednostavno: potrebno je zameniti poziv funkcije njenim telom. Umetanje uklanja neke pozive funkcija, ali jednako je važno da umetanje spaja kod koje je prethodno razvdojen i zbog toga se implementira u okviru pojednostavljivača \cite{compilation-by-program-transformation}.

Korisno je definisati tri različite transformacije koje zajedno implementiraju ono što neformalno opisujemo kao ‚‚umetanje$"$ \cite{secrets-haskell-compiler-inliner, compilation-by-program-transformation}, :
\begin{itemize}
	\item \textit{Samo umetanje} (engl. \textit{inlining itself}) zamenjuje sva pojavljivanja vezane promenljive kopijom desne strane njene definicije. Pogledajmo to na primeru:
	$$ \text{let } \{ f = \backslash x \longrightarrow x*3 \} \text{ in } f (a + b) - c \stackrel{\text{inline f}}{\longrightarrow} $$
	$$\text{let} \{ f = \backslash x \longrightarrow x*3 \} \text{ in } (\backslash x \longrightarrow x*3) (a + b) - c$$
	
	\item \textit{Eliminacija mrtvog koda} (engl. \textit{dead code elimination}) odbacuje veze koje se više ne koriste. Ovo se najčešće dešava kada je svaka pojava promenljive umetnuta. Nadovežimo se na prethodni primer:
	$$\text{let} \{ f = \backslash x \longrightarrow x*3 \} \text{ in } (\backslash x \longrightarrow x*3) (a + b) - c $$ 
	$$\stackrel{\text{dead f}}{\longrightarrow}  (\backslash x \longrightarrow x*3) (a + b) - c $$
	
	\item \textit{$\beta$-odsecanje} (engl. \textit{$\beta$}-reduction) jednostavno prezapiše $\lambda$ izraz $(\backslash x \longrightarrow E) A$ u $let \{x = A\} \text{ in } E$. U našem primeru to izgleda ovako:
	$$(\backslash x \longrightarrow x*3) (a + b) - c \stackrel{\beta}{\longrightarrow} (\text{let} \{ x = a+b \} \text{ in } x*3) - c$$
\end{itemize}


\subsection{Uparivanje šablona}

% compilingML.A4.pdf str. 5 + 1wilhelm_r_seidl_h_compiler_design_virtual_machines str. 69
 
Funkcije nad strukturiranim algebarskim tipovima, kao što su liste, mogu se definisati preko različitih slučajeva (engl. \textit{case}). Različiti slučajevi dati su \textit{šablonima}, koji se uparuju prema vrednostima tog tipa. Ako šablon odgovara vrednosti, promenljive koje se mogu pojaviti u šablonu su vezane za odgovarajuće promenljive komponente te vrednosti. U izrazu uparujemo $[1; 2; 3]$  sa $[1; x; y] \longrightarrow x+y$ |  $[z] \longrightarrow z$. Vidimo da se izraz poklapa sa prvim šablonom. Promenljive $x$ i $y$ vezuju za komponente 2 i 3 i vraća se njihova suma. Ovakvo poređenje na osnovu šablona naziva se \textit{uparivanje šablona} \cite{compiler-design, compiling-fl}. Uparivanje šablona prenosi visoko strukturirane informacije o parametrima ulaza. Kao posledicu, kompajler proizvodi bolji k\^ od iz opisa koji dobija od uparivanja šablona nego od odgovarajućih sekvenci operacija izbora. %naci referencu nekako xD

Uparivanje šablona je zapravo skraćenica za ugnježdene if-then-else i case naredbe (engl. \textit{statements}): pokušaj da upariš ulaz da prvim šablonom, ako se poklapa izvrši odgovarajuću akciju, u suprotnom se vrati korak nazad i pokušaj sa sledećim šablonom. Ova strategija proizvodi nepotreban rad. Kompajleri to mnogo bolje rade tako što šablone kompajliraju u diskriminišuće stablo (engl. \textit{discrimination tree}) koje to radi u skoro optimalnom broju testova nad podacima kako bi odabralo odgovarajuću akciju. 
