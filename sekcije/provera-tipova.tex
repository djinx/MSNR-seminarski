% TODO: pročitajte i dajte svoj sud
% ovo poglavlje je nezvanicno završeno
% potencijalno treba da se dopuni ili lepše zapiše da bi sve delovalo kao jedna celina

\section{Polimorfna provera tipova}
\label{sec:provera tipova}


%The Implementation of Functional Programming Languages strana 139
Neki moderni jezici, kao što je Miranda, imaju svojstvo koje omogućava programeru da ne navodi tipove objekata koje definiše u programu. Kompajler može da odredi tipove ako je to moguće. Deo kompajlera koji se bavi ovim poslom naziva se \textit{proveravač tipova}. Proveravač tipova je od velike koristi programeru jer mu ukazuje na greške, od trivijalnih propusta u kucanju do velikih logičkih grešaka. Pomaže u pisanju robusnih programa kao i u izgradnji bržih implementacija programskih jezika. Ako proveravač tipova obradi program, pri izvršavanju ne bi trebalo da se jave greške poput upotrebe promenljive tipa bool kao da je tipa int.
\\
\\ %BasicTypechecking.pdf str. 6
% potrebna referenca za unifikaciju

Izrazi koji sadrže nekoliko pojavljivanja istog tipa, kao $\alpha \longrightarrow \alpha$, izražavaju kontekstu zavisnost, u ovom slučaju to je zavisnost domena i kodomena tipa funkcije. Proces proveravanja tipova sastoji se od uparivanja tipova operatora i instanciranja tipova promenljivih. Kad god tip promenljive instancira, sve ostale pojave iste promenljive moraju biti instancirane sa istom vrednošću: ispravna instanciranja izraza $\alpha \longrightarrow \alpha$ su $int \longrightarrow int$,  $bool \longrightarrow bool$, itd. Proces kontkestnog instanciranja izvodi se pomoću \textit{unifikacije} i ona je osnova polimorfne provere tipova. Unifikacija ne uspeva kada pokušava da upari dva operatora različitih tipova (nor. int i bool) ili kada pokušava da instancira promeljivu izrazom koji sadrži tu promenljivu (npr. $a$ i $a\longrightarrow b$, gde će se napraviti rekurzija bez izlaza). %The latter situation arises in typechecking self-application (e.g. fun(x) x(x)), which is therefore considered illegal.
U opštem slučaju, tip izraza određuje se pomoću skupa pravila kombinovanja tipova za jezičke konstrukcije i tipova primitivnih operatora. 

\iffalse
%The Implementation of Functional Programming Languages sekcija 8.1
\subsection{Ukratko o notaciji}
%ovo je sve nebitno zapravo, ali neka stoji za sad :D
Tipovi koji su zanimljivi kada je funkcionalno programiranju u pitanju su karakteri, broj, istinitosna vrednost, kao i tipovi torki, lista i funkcija. Kada govorimo o ovim tipovima, koristićemo sledeću notaciju:
$$a::A$$

\noindent što predstavlja promenljivu $a$ koja je tipa $A$. 	
\\
\\ Ako su dati tipovi $A_1, \ldots, A_n$ onda $(A_1, \ldots, A_n)$ predstavlja tip tokre $(a_1, \ldots, a_n)$ za koji važi $a_1::A_1$ i $a_n::A_n$. Bitno je naglasiti da $A_1, \ldots, A_n$ ne predstavljaju iste tipove, odnosno da koordinate jedne torke ne moraju biti sve istog tipa. Takođe, tip torke određuje broj koordinata (odnosno dimenziju torke) i njihove tipove. 
\\
\\ Ako je dat tip $A$ onda je $[B]$ tip liste čiji su elementi tipa $B$. U slučaju da su elementi liste torke, sve torke moraju biti istog tipa. Za razliku od tipa torke, tip liste ne određuje njenu dužinu. 
\\
\\ Ako su dati tipovi $A$ i $B$ koristimo $A \longrightarrow B$ za zapis tipa funkcije $f$ koja se primenjuje na promenljivu $a::A$, a čije vrednosti $(f \quad a)$ su tipa $B$.


\fi 


%BasicTypechecking.pdf str. 9
\subsection{Zaključivanje tipova}

Osnovni algoritam za zaključivanje tipova opisan je u nastavku.

\begin{enumerate}
	\item Kada se pojavi nova promenljiva $x$, njoj se dodeljuje novi tip promenljive što znači da joj tip mora biti određen u daljem kontekstu u kom se pojavljuje. Par $<x, a>$ se čuva u okruženje koje se pretražuje svaki put kad se pojavi $x$ u kom je $x$ tipa $a$.
	
	\item Kad imamo uslovno grananje, \textit{if} se uparuje sa bool, dok se \textit{then} i \textit{else} grane ostavljaju nedefinisane kako bi se odredio jedinstven tip za ceo izraz.
	
	\item U apstrakciji $\lambda x.e$, tip za $e$ se zaključuje u kontekstu gde je $x$ povezan sa novim tipom promenljive.
	
	\item U aplikaciji $f(a)$, tip od f se unifikuje sa tipom $A \longrightarrow b$, gde je $A$ tip parametra $a$, dok je $b$ novi tip promenljive. Ovo ukazuje na to da $f$ mora biti tipa funkcije čiji domen se unifikuje sa $A$, a $b$ je tip povratne vrednosti.
\end{enumerate}



