\section{Polimorfna provera tipova}
\label{sec:provera tipova}


%The Implementation of Functional Programming Languages strana 139
Neki moderni jezici, kao što je Miranda, imaju svojstvo koje omogućava programeru da ne navodi tipove objekata koje definiše u programu. Kompajler može da odredi tipove ako je to moguće. Deo kompajlera koji se bavi ovim poslom naziva se \textit{proveravač tipova}. Proveravač tipova je od velike koristi programeru jer mu ukazuje na greške, od trivijalnih propusta u kucanju do velikih logičkih grešaka. Pomaže u pisanju robusnih programa kao i u izgradnji bržih implementacija programskih jezika. Ako proveravač tipova obradi program, pri izvršavanju ne bi trebalo da se jave greške poput upotrebe promenljive tipa boolean kao da je tipa integer.

\iffalse
%The Implementation of Functional Programming Languages sekcija 8.1
\subsection{Ukratko o notaciji}
%ovo je sve nebitno zapravo, ali neka stoji za sad :D
Tipovi koji su zanimljivi kada je funkcionalno programiranju u pitanju su karakteri, broj, istinitosna vrednost, kao i tipovi torki, lista i funkcija. Kada govorimo o ovim tipovima, koristićemo sledeću notaciju:
$$a::A$$

\noindent što predstavlja promenljivu $a$ koja je tipa $A$. 	
\\
\\ Ako su dati tipovi $A_1, \ldots, A_n$ onda $(A_1, \ldots, A_n)$ predstavlja tip tokre $(a_1, \ldots, a_n)$ za koji važi $a_1::A_1$ i $a_n::A_n$. Bitno je naglasiti da $A_1, \ldots, A_n$ ne predstavljaju iste tipove, odnosno da koordinate jedne torke ne moraju biti sve istog tipa. Takođe, tip torke određuje broj koordinata (odnosno dimenziju torke) i njihove tipove. 
\\
\\ Ako je dat tip $A$ onda je $[B]$ tip liste čiji su elementi tipa $B$. U slučaju da su elementi liste torke, sve torke moraju biti istog tipa. Za razliku od tipa torke, tip liste ne određuje njenu dužinu. 
\\
\\ Ako su dati tipovi $A$ i $B$ koristimo $A \longrightarrow B$ za zapis tipa funkcije $f$ koja se primenjuje na promenljivu $a::A$, a čije vrednosti $(f \quad a)$ su tipa $B$.


\fi 


%potencijalno nebitno
\subsection{Polimorfizam}

Polimorfizam ima više oblika. Kada je reč o programskim jezicima, odnosi se na funkcije koje mogu da imaju više različitih tipova. Najviše nas interesuje \textit{parametarski polimorfizam}. Postoje dva glavna načina za ostaavrivanje polimorfizma, a to su \textit{eksplicitni} i \textit{implicitni}. %možda dopuniti i pronaći reference za eksplicitni i implicitni polimorfizam


%BasicTypechecking.pdf str. 9
\subsection{Zaključivanje tipova}

Osnovni algoritam za zaključivanje tipova opisan je u nastavku.

\begin{enumerate}
	\item Kada se pojavi nova promenljiva $x$, njoj se dodeljuje novi tip promenljive što znači da joj tip mora biti određen u daljem kontekstu u kom se pojavljuje. Par $<x, a>$ se čuva u okruženje koje se pretražuje svaki put kad se pojavi $x$ u kom je $x$ tipa $a$.
	
	\item Kad imamo uslovno grananje, \textit{if} se uparuje sa bool, dok se \textit{then} i \textit{else} grane ostavljaju nedefinisane kako bi se odredio jedinstven tip za ceo izraz.
	
	\item U apstrakciji $\lambda x.e$, tip za $e$ se zaključuje u kontekstu gde je $x$ povezan sa novim tipom promenljive.
	
	\item U aplikaciji $f(a)$, tip od f se unifikuje sa tipom $A \longrightarrow b$, gde je $A$ tip parametra $a$, dok je $b$ novi tip promenljive. Ovo ukazuje na to da $f$ mora biti tipa funkcije čiji domen se unifikuje sa $A$, a $b$ je tip povratne vrednosti.
\end{enumerate}



